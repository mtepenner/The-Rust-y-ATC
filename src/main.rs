// Gemini 2.5 Pro was used to create this code

// Declare the modules that Rust will look for in other files
mod airport;
mod flight_plan;
mod game;
mod plane;

use std::io::{self, Write};
use std::thread;
use std::time::Duration;

/// Clears the terminal screen.
fn clear_screen() {
    // \x1B[2J clears the entire screen
    // \x1B[1;1H moves the cursor to row 1, column 1
    print!("\x1B[2J\x1B[1;1H");
    io::stdout().flush().unwrap();
}

/// Helper function to read a single line of input from the user.
fn get_user_input() -> String {
    let mut input = String::new();
    io::stdin()
        .read_line(&mut input)
        .expect("Failed to read line");
    input.trim().to_string()
}

/// Displays the main title and menu, returning the user's choice.
fn show_main_menu() -> String {
    clear_screen();
    // ASCII Art Title
    println!(r"");
    println!(r"___________.__             __________                __              _________________________  ");
    println!(r"\__    ___/|  |__   ____   \______   \__ __  _______/  |_ ___.__.   /  _  \__    ___/\_   ___ \ ");
    println!(r"  |    |   |  |  \_/ __ \   |       _/  |  \/  ___/\   __<   |  |  /  /_\  \|    |   /    \  \/ ");
    println!(r"  |    |   |   Y  \  ___/   |    |   \  |  /\___ \  |  |  \___  | /    |    \    |   \     \____");
    println!(r"  |____|   |___|  /\___  >  |____|_  /____//____  > |__|  / ____| \____|__  /____|    \______  /");
    println!(r"                \/     \/          \/           \/        \/              \/                 \/ ");
    println!(r"");
    println!(r"-----------------------------------------------------------------------------------------------");
    println!(r"");
    println!(r"    [1] Start New Game");
    println!(r"    [2] How to Play");
    println!(r"    [3] Quit");
    println!(r"");
    print!("    Enter your choice: ");
    io::stdout().flush().unwrap();
    get_user_input()
}

/// Displays the "How to Play" instructions.
fn show_how_to_play() {
    clear_screen();
    println!(r"----------------- HOW TO PLAY -----------------");
    println!(r"");
    println!(r"Welcome to The Rust-y ATC! Your job is to manage the aircraft");
    println!(r"at a busy airport. You will get points for successful");
    println!(r"movements and penalties for mistakes.");
    println!(r"");
    println!(r"COMMANDS:");
    println!(r"  pushback [id]     - Clears a 'Ready for Pushback' plane to taxi.");
    println!(r"                      (e.g., 'pushback SWA123')");
    println!(r"");
    println!(r"  takeoff [id] [rw] - Clears a 'Ready for Takeoff' plane to depart.");
    println!(r"                      (e.g., 'takeoff SWA123 24L')");
    println!(r"");
    println!(r"  land [id] [rw]    - Clears a 'Ready to Land' plane to arrive.");
    println!(r"                      (e.g., 'land DAL456 18')");
    println!(r"");
    println!(r"  wait              - Does nothing and advances the game clock.");
    println!(r"                      (Useful if no actions are needed)");
    println!(r"");
    println!(r"  quit              - Quits the current game.");
    println!(r"");
    println!(r"SCORING:");
    println!(r"  +10 points - Successful Takeoff or Landing.");
    println!(r"  +5 points  - Successful Pushback.");
    println!(r"  -5 points  - Any penalty.");
    println!(r"");
    println!(r"PENALTIES:");
    println!(r"  - Giving a command to a plane that isn't ready.");
    println!(r"  - Clearing a plane for pushback while it's still boarding.");
    println!(r"  - Using a runway that is CLOSED due to weather.");
    println!(r"  - Getting 3 penalties in a row ends the game.");
    println!(r"");
    println!(r"-----------------------------------------------");
    println!(r"");
    print!("Press [Enter] to return to the main menu...");
    io::stdout().flush().unwrap();
    get_user_input(); // Wait for user to press Enter
}

/// The main game loop where the simulation runs.
fn run_game() {
    let mut game = game::Game::new();
    clear_screen();
    println!("--- Air Traffic Controller Simulator ---");
    println!("Welcome! Manage the airport. Don't mess up.");
    println!("(Type 'quit' to exit the game at any time)");
    thread::sleep(Duration::from_millis(2500)); // Pause to read

    while !game.is_game_over() {
        clear_screen(); // Clear screen for a fresh "radar" view
        game.draw();

        // Get user input (with a simple prompt)
        print!("> ");
        io::stdout().flush().unwrap();

        let input = get_user_input();
        if input.eq_ignore_ascii_case("quit") {
            // Also check for "quit" inside the game loop
            game.process_command(input);
            break; // Exit the game loop
        }

        // Process the command
        game.process_command(input);

        // Update the game state (the "tick")
        // We only tick *after* a command is processed
        game.update();

        // Wait for the next tick *if* the game isn't over
        if !game.is_game_over() {
            // We sleep for a shorter time because the input reading
            // also takes time, making the 2-sec tick feel longer.
            // Let's make the "wait" time 1.5s
            thread::sleep(Duration::from_millis(1500));
        }
    }

    // Game is over, wait for user to see the "fired" message
    if game.is_game_over() {
        println!("\nPress [Enter] to return to the main menu...");
        io::stdout().flush().unwrap();
        get_user_input(); // Wait for user
    }
    // If user just typed "quit", return to menu immediately
}

// --- MAIN FUNCTION ---
// Entry point, contains the application menu loop
fn main() {
    loop {
        let choice = show_main_menu();

        match choice.as_str() {
            "1" => {
                // Start the game
                run_game();
            }
            "2" => {
                // Show "How to Play"
                show_how_to_play();
            }
            "3" => {
                // Quit the program
                clear_screen();
                println!("Goodbye!");
                break;
            }
            _ => {
                // Handle invalid input
                println!("Invalid choice. Press [Enter] to try again...");
                io::stdout().flush().unwrap();
                get_user_input();
            }
        }
    }
}
